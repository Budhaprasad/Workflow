name: Clean Blocked Issue Comments

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'  # every hour

permissions:
  issues: write
  contents: read

jobs:
  clean-blocked-comments:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up closed issue references
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const regex = /#(\d+)/g;

            console.log(`ğŸ“Œ Scanning open issues in ${owner}/${repo}`);

            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open'
            });

            for (const issue of issues) {
              console.log(`\nğŸ” Issue #${issue.number}: ${issue.title}`);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issue.number
              });

              for (const comment of comments) {
                const originalBody = comment.body;
                const matches = [...originalBody.matchAll(regex)];
                const referencedIssues = matches.map(match => parseInt(match[1]));

                if (referencedIssues.length === 0) {
                  console.log(`   ğŸ’¬ Comment ID: ${comment.id}`);
                  console.log(`     ğŸš« No 'Blocked by' reference found.`);
                  continue;
                }

                console.log(`   ğŸ’¬ Comment ID: ${comment.id}`);
                console.log(`     ğŸ“„ Raw: "${originalBody.trim()}"`);

                const stillBlocked = [];

                for (const ref of referencedIssues) {
                  try {
                    const refIssue = await github.rest.issues.get({ owner, repo, issue_number: ref });
                    if (refIssue.data.state === 'open') {
                      stillBlocked.push(`#${ref}`);
                      console.log(`     ğŸ”— Found reference to issue #${ref}`);
                      console.log(`     â³ Issue #${ref} is still open.`);
                    } else {
                      console.log(`     ğŸ”— Found reference to issue #${ref}`);
                      console.log(`     âœ… Issue #${ref} is closed.`);
                    }
                  } catch (err) {
                    console.warn(`     âš ï¸ Error fetching issue #${ref}: ${err.message}`);
                  }
                }

                if (stillBlocked.length === 0) {
                  const newBody = `[Auto-cleaned: all blocking issues are closed]`;
                  console.log(`     ğŸ§¹ Updating comment to: "${newBody}"`);
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: comment.id,
                    body: newBody
                  });
                } else {
                  const newBody = `Blocked by ${stillBlocked.join(' ')}`;
                  if (newBody !== originalBody.trim()) {
                    console.log(`     âœï¸ Updating comment to: "${newBody}"`);
                    await github.rest.issues.updateComment({
                      owner,
                      repo,
                      comment_id: comment.id,
                      body: newBody
                    });
                  } else {
                    console.log(`     âœ… Comment is already correct. No update needed.`);
                  }
                }
              }
            }
