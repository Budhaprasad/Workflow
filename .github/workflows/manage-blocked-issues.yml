name: Manage Blocked Issues

on:
  workflow_dispatch:

jobs:
  manage-blocks:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Clean Blocked by Comments and Manage Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const regex = /Blocked by\s*(#[\d\s]+)/gi;

            console.log(`🔍 Scanning open issues in ${owner}/${repo}`);
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });

            for (const issue of issues) {
              const labels = issue.labels.map(l => l.name);
              const statusLabels = ['To-Do', 'Blocked'];
              const currentStatus = labels.find(l => statusLabels.includes(l));
              const otherLabels = labels.filter(l => !statusLabels.includes(l));

              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: issue.number,
              });

              for (const comment of comments.data) {
                const matches = [...comment.body.matchAll(regex)];
                if (matches.length === 0) continue;

                const allRefs = matches.flatMap(m =>
                  m[1].match(/#(\d+)/g)?.map(n => parseInt(n.replace('#', ''))) || []
                );

                let openRefs = [];
                let validRefs = [];

                for (const refNum of allRefs) {
                  try {
                    const refIssue = await github.rest.issues.get({
                      owner,
                      repo,
                      issue_number: refNum,
                    });
                    validRefs.push(`#${refNum}`);
                    if (refIssue.data.state === 'open') {
                      openRefs.push(`#${refNum}`);
                    }
                  } catch (e) {
                    console.warn(`❌ Issue #${refNum} not found.`);
                  }
                }

                const newComment = openRefs.length > 0 ? `Blocked by ${openRefs.join(' ')}` : '';
                if (newComment && comment.body.trim() !== newComment) {
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: comment.id,
                    body: newComment,
                  });
                  console.log(`📝 Updated comment on issue #${issue.number}`);
                }

                if (!newComment) {
                  // Remove comment
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: comment.id,
                    body: '[Auto-removed blocked-by reference: the blocking issues are all closed.]'
                  });
                  console.log(`🧹 Cleaned comment in #${issue.number}`);
                }

                // Manage Labels
                const hasBlocked = openRefs.length > 0;

                if (hasBlocked && !labels.includes('Blocked')) {
                  // Add "Blocked", remove "To-Do"
                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: issue.number,
                    labels: [...otherLabels, 'Blocked'],
                  });
                  console.log(`🚫 Set "Blocked" label on #${issue.number}`);
                }

                if (!hasBlocked && labels.includes('Blocked')) {
                  // Remove "Blocked", set to "To-Do"
                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: issue.number,
                    labels: [...otherLabels, 'To-Do'],
                  });
                  console.log(`✅ All blockers resolved. Set "To-Do" on #${issue.number}`);
                }
              }
            }
