# .github/workflows/issue-blocker.yml

name: "Auto Manage Issue Blockers"

on:
  workflow_dispatch:

permissions:
  issues: write

jobs:
  clean-blocked-comments:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up 'Blocked by' references and manage issue status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const regex = /#(\d+)/g;
            const statusLabels = ["To-Do", "In Progress", "Blocked", "Done"];
            
            const issues = await github.rest.issues.listForRepo({ owner, repo, state: 'open' });
            
            for (const issue of issues.data) {
              if (issue.pull_request) continue;
              console.log(`\n🔍 Issue #${issue.number}: ${issue.title}`);
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number: issue.number });
              let hasBlocker = false;
              let updatedComment = false;

              for (const comment of comments.data) {
                if (!comment.body.toLowerCase().includes('blocked by')) continue;
                const matches = [...comment.body.matchAll(regex)].map(m => parseInt(m[1]));
                const stillOpen = [];

                for (const ref of matches) {
                  try {
                    const refIssue = await github.rest.issues.get({ owner, repo, issue_number: ref });
                    if (refIssue.data.state === 'open') {
                      stillOpen.push(`#${ref}`);
                    }
                  } catch (err) {
                    console.warn(`⚠️ Issue #${ref} could not be fetched.`);
                  }
                }

                const newBody = stillOpen.length > 0
                  ? `Blocked by ${stillOpen.join(' ')}`
                  : '[Auto-removed blocked-by reference: all blocking issues closed.]';

                if (comment.body !== newBody) {
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: comment.id,
                    body: newBody
                  });
                  updatedComment = true;
                }

                if (stillOpen.length > 0) hasBlocker = true;
              }

              const labels = issue.labels.map(l => l.name);
              const currentStatus = labels.find(l => statusLabels.includes(l));

              if (hasBlocker) {
                if (currentStatus !== 'Blocked') {
                  // Store current status as previous-status if not already blocked
                  if (currentStatus && currentStatus !== 'Blocked') {
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [`previous-status:${currentStatus}`] });
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: currentStatus });
                  }
                  if (!labels.includes('Blocked')) {
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['Blocked'] });
                    console.log(`🏷️ Label 'Blocked' added.`);
                  }
                }
              } else {
                // No blockers remain
                if (labels.includes('Blocked')) {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: 'Blocked' });
                  console.log(`✅ 'Blocked' label removed.`);

                  const previousStatus = labels.find(l => l.startsWith('previous-status:'));
                  if (previousStatus) {
                    const restored = previousStatus.split(':')[1];
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [restored] });
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: previousStatus });
                    console.log(`🔄 Restored previous status: ${restored}`);
                  } else {
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['To-Do'] });
                    console.log(`📝 Defaulted status to 'To-Do'`);
                  }
                }
              }
            }
